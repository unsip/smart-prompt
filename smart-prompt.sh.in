#!/bin/bash
#
# This is a `main` module of the SmartPrompt engine.
#
# Smart Prompt @PROJECT_VERSION@
# Copyright (c) 2013-2018 Alex Turbov <i.zaufi@gmail.com>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#

# Check for interactive bash and that we haven't already been sourced.
[[ -z "$BASH_VERSION" || -z "$PS1" || -n "$SMART_PROMPT_PLUGINS" ]] && return

# Load configuration file
if [[ -f @SMART_PROMPT_CONFIG@ ]]; then
    source @SMART_PROMPT_CONFIG@
fi

# Load user level overrides
if [[ -f ~/.@PROJECT_NAME@rc ]]; then
    source ~/.@PROJECT_NAME@rc
fi

# Declare a global associative array to be filled by found plugins
declare -A SMART_PROMPT_PLUGINS

# Loading plugins
if [[ -d @CMAKE_INSTALL_LIBEXECDIR@/@PROJECT_NAME@/context-checkers.d ]]; then
    for plugin in @CMAKE_INSTALL_LIBEXECDIR@/@PROJECT_NAME@/context-checkers.d/[0-9][0-9]*.sh; do
        if [[ -n ${SP_SHOW_DEBUG} ]]; then
            echo "sp: loading ${plugin}..."
        fi
        source ${plugin}
    done
fi

# Loading user plugins
if [[ -d ~/.@PROJECT_NAME@.d ]]; then

    for plugin in ~/.@PROJECT_NAME@.d/[0-9][0-9]*.sh; do
        if [[ -n ${SP_SHOW_DEBUG} ]]; then
            echo "sp: loading ${plugin}..."
        fi
        source ${plugin}
    done
fi

# Include reusable functions into the scope
if [[ -f @CMAKE_INSTALL_LIBEXECDIR@/@PROJECT_NAME@/@PROJECT_NAME@-functions.sh ]]; then
    source @CMAKE_INSTALL_LIBEXECDIR@/@PROJECT_NAME@/@PROJECT_NAME@-functions.sh
else
    logger -t @PROJECT_NAME@ "Reusable functions library " \
        "'@CMAKE_INSTALL_LIBEXECDIR@/@PROJECT_NAME@/@PROJECT_NAME@-functions.sh' "   \
        "not found. Installation seems broken!"
    return
fi

function _get_registered_context_checkers()
{
    for checker in "${!SMART_PROMPT_PLUGINS[@]}"; do
        echo "${checker}"
    done | sort
}

function _smart_prompt()
{
    local sp_path
    local sp_user
    local sp_reset

    # Get configured colors (or defaults)
    # NOTE Before set desired color, make sure there is no
    # other styles in effect...it is why `reset' is a leading
    # (and hardcoded) "color" in a sequence...
    _eval_color_string "reset ${SP_PATH:-bright-blue}" sp_path
    if [[ ${EUID} != 0 ]]; then
        _eval_color_string "reset ${SP_USER:-bright-green}" sp_user
    else
        _eval_color_string "reset ${SP_SUSER:-bright-red}" sp_user
    fi
    _eval_color_string 'reset' sp_reset
    local sp_alert
    _eval_color_string "reset ${SP_ALERT:-'bright-red'}" sp_alert
    local sp_warn
    _eval_color_string "reset ${SP_WARN:-'yellow'}" sp_warn
    local sp_info
    _eval_color_string "reset ${SP_INFO:-'bright-green'}" sp_info
    local sp_notice
    _eval_color_string "reset ${SP_NOTICE:-'bright-cyan'}" sp_notice
    local sp_debug
    _eval_color_string "reset ${SP_DEBUG:-'dark-grey'}" sp_debug
    local sp_misc
    _eval_color_string "reset ${SP_MISC:-'white'}" sp_misc

    # Get some other (non color) configurable parameters
    local -r sp_time_fmt=${SP_TIME_FMT:-%H:%M %d/%m}
    local -r sp_seg=${sp_path}${SP_SEGMENT_DELIMITER:-"\342\214\252"}

    # Iterate over registered plugins and collect strings to be appended to PS1
    local sp_ps=''
    for checker in $(_get_registered_context_checkers); do
        if [[ -n "${SP_SHOW_DEBUG}" ]]; then
            echo -n "checking ${checker}... "
        fi
        if ${checker}; then
            if [[ -n "${SP_SHOW_DEBUG}" ]]; then
                echo "ok"
            fi
            for action in ${SMART_PROMPT_PLUGINS[$checker]}; do
                sp_ps+="`${action}`${sp_seg}"
            done
        elif [[ -n "${SP_SHOW_DEBUG}" ]]; then
            echo "!!"
        fi
    done
    # Form the final PS1
    PS1="${sp_ps}${sp_reset}"
}

export PROMPT_COMMAND=_smart_prompt

# kate: hl bash;
