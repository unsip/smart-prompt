#!/bin/bash
#
# This is a `main` module of the SmartPrompt engine.
#
# Smart Prompt @SP_VERSION@
# Copyright (c) 2013 Alex Turbov <i.zaufi@gmail.com>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#

# Check for interactive bash and that we haven't already been sourced.
[ -z "$BASH_VERSION" -o -z "$PS1" -o -n "$SMART_PROMPT_PLUGINS" ] && return

# Load configuration file
if [ -f @SMART_PROMPT_CONFIG@ ]; then
    source @SMART_PROMPT_CONFIG@
fi

# Load user level overrides
if [ -f ~/.@PROJECT_NAME@rc ]; then
    source ~/.@PROJECT_NAME@rc
fi

# Declare a global associative array to be filled by found plugins
declare -A SMART_PROMPT_PLUGINS

# Loading user plugins
if [ -d ~/.@PROJECT_NAME@.d ]; then
    for plugin in `ls -v1 ~/.@PROJECT_NAME@.d/[0-9][0-9]*.sh`; do
        #echo "loading ${plugin}..."
        source ${plugin}
    done
fi

# Loading plugins
if [ -d @SP_CONTEXT_CHECKERS_DIR@ ]; then
    for plugin in `ls -v1 @SP_CONTEXT_CHECKERS_DIR@/[0-9][0-9]*.sh`; do
        if [ -n "${SP_SHOW_DEBUG}" ]; then
            echo "sp: loading ${plugin}..."
        fi
        source ${plugin}
    done
fi

# Include reusable functions into the scope
if [ -f @SP_LIBEXECDIR@/@PROJECT_NAME@-functions.sh ]; then
    source @SP_LIBEXECDIR@/@PROJECT_NAME@-functions.sh
else
    logger -t @PROJECT_NAME@ "Reusable functions library " \
        "'@SP_LIBEXECDIR@/@PROJECT_NAME@-functions.sh' "   \
        "not found. Installation seems broken!"
    return
fi

function _get_registered_context_checkers()
{
    for checker in "${!SMART_PROMPT_PLUGINS[@]}"; do
        echo "${checker}"
    done | sort
}

function _smart_prompt()
{
    local sp_path
    local sp_user
    local sp_reset

    # Get configured colors (or defaults)
    # NOTE Before set desired color, make sure there is no
    # other styles in effect...it is why `reset' is a leading
    # (and hardcoded) "color" in a sequence...
    _eval_color_string "reset ${SP_PATH:-bright-blue}" sp_path
    if [[ ${EUID} != 0 ]]; then
        _eval_color_string "reset ${SP_USER:-bright-green}" sp_user
    else
        _eval_color_string "reset ${SP_SUSER:-bright-red}" sp_user
    fi
    _eval_color_string 'reset' sp_reset
    local sp_alert
    _eval_color_string "reset ${SP_ALERT:-'bright-red'}" sp_alert
    local sp_warn
    _eval_color_string "reset ${SP_WARN:-'yellow'}" sp_warn
    local sp_info
    _eval_color_string "reset ${SP_INFO:-'bright-green'}" sp_info
    local sp_notice
    _eval_color_string "reset ${SP_NOTICE:-'bright-cyan'}" sp_notice
    local sp_debug
    _eval_color_string "reset ${SP_DEBUG:-'dark-grey'}" sp_debug
    local sp_misc
    _eval_color_string "reset ${SP_MISC:-'white'}" sp_misc

    # Get some other (non color) configurable parameters
    local -r sp_time_fmt=${SP_TIME_FMT:-%H:%M %d/%m}
    local -r sp_seg=${sp_path}${SP_SEGMENT_DELIMITER:-"\342\214\252"}

    # TODO Make the prompt format configurable? Really?
    local start="${sp_user}\u@\h${sp_seg}\w${sp_seg}"

    # Iterate over registered plugins and collect strings to be appended to PS1
    local middle=''
    for checker in $(_get_registered_context_checkers); do
        if [ -n "${SP_SHOW_DEBUG}" ]; then
            echo -n "checking ${checker}... "
        fi
        if `${checker}`; then
            if [ -n "${SP_SHOW_DEBUG}" ]; then
                echo "ok"
            fi
            for action in ${SMART_PROMPT_PLUGINS[$checker]}; do
                middle+="`${action}`${sp_seg}"
            done
        elif [ -n "${SP_SHOW_DEBUG}" ]; then
            echo "!!"
        fi
    done
    # Form the final PS1
    PS1="${start}${middle}${sp_reset}"
}

export PROMPT_COMMAND=_smart_prompt

# kate: hl bash;
